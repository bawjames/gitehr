#!/usr/bin/env python3

import argparse
import json
import os
import shutil
import subprocess
import sys


def eprint(*args):
    print(*args, file=sys.stderr)


def run(cmd, cwd=None):
    subprocess.run(cmd, cwd=cwd, check=True)


def load_mpi(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def resolve_repo_from_mpi(store_root, mpi_path):
    mpi = load_mpi(mpi_path)
    patients = mpi.get("patients", [])
    if not patients:
        raise RuntimeError("MPI has no patients after init")
    last = patients[-1]
    repo_path = last.get("repo_path")
    if not repo_path:
        raise RuntimeError("MPI patient record missing repo_path")
    return os.path.join(store_root, repo_path)


def main():
    parser = argparse.ArgumentParser(description="Generate many GitEHR repos for benchmarking")
    parser.add_argument("-repos", type=int, required=True, dest="repos")
    parser.add_argument("-journal-entries", type=int, required=True, dest="journal_entries")
    parser.add_argument("--gitehr", default="gitehr", help="Path to gitehr binary (default: gitehr)")
    parser.add_argument("--no-journal", action="store_true", help="Skip journal entry creation")
    parser.add_argument("--parallel", type=int, default=1, help="Number of repos to create in parallel")
    parser.add_argument("--yes", action="store_true", help="Skip confirmation")
    args = parser.parse_args()

    if args.repos <= 0:
        eprint("-repos must be a positive integer")
        sys.exit(1)
    if args.journal_entries <= 0 and not args.no_journal:
        eprint("-journal-entries must be a positive integer, or use --no-journal")
        sys.exit(1)
    if args.parallel <= 0:
        eprint("--parallel must be a positive integer")
        sys.exit(1)

    store_root = os.getcwd()
    if os.path.isdir(os.path.join(store_root, ".gitehr")):
        eprint("Refusing to run inside a GitEHR repo. Run from the store root.")
        sys.exit(1)

    gitehr_bin = args.gitehr
    if os.sep not in gitehr_bin and shutil.which(gitehr_bin) is None:
        eprint(f"gitehr binary not found: {gitehr_bin}")
        sys.exit(1)

    if not args.yes:
        eprint("This will generate large numbers of repos and files using native gitehr commands.")
        eprint(f"Store root: {store_root}")
        eprint(f"Repos: {args.repos}")
        if args.no_journal:
            eprint("Journal entries per repo: (skipped)")
        else:
            eprint(f"Journal entries per repo: {args.journal_entries}")
        eprint(f"Parallel workers: {args.parallel}")
        eprint(f"gitehr: {gitehr_bin}")
        eprint("Type the full store root path to confirm:")
        confirm = sys.stdin.readline().strip()
        if confirm != store_root:
            eprint("Confirmation failed. Aborting.")
            sys.exit(1)

    mpi_path = os.path.join(store_root, "gitehr-mpi.json")

    if args.parallel == 1:
        for _ in range(args.repos):
            run([gitehr_bin, "init"], cwd=store_root)
            repo_dir = resolve_repo_from_mpi(store_root, mpi_path)

            if not args.no_journal:
                for i in range(args.journal_entries):
                    run([gitehr_bin, "journal", "add", f"Generated entry {i + 1}."], cwd=repo_dir)
    else:
        eprint("WARNING: Parallel generation can interleave MPI writes and may fail")
        workers = args.parallel
        per_worker = args.repos // workers
        remainder = args.repos % workers
        procs = []

        for w in range(workers):
            count = per_worker + (1 if w < remainder else 0)
            if count == 0:
                continue
            cmd = [
                sys.executable,
                os.path.abspath(__file__),
                "-repos",
                str(count),
                "-journal-entries",
                str(args.journal_entries),
                "--gitehr",
                gitehr_bin,
                "--yes",
            ]
            if args.no_journal:
                cmd.append("--no-journal")
            cmd.append("--parallel")
            cmd.append("1")
            procs.append(subprocess.Popen(cmd, cwd=store_root))

        for p in procs:
            if p.wait() != 0:
                sys.exit(p.returncode)


if __name__ == "__main__":
    main()
